面试 相关知识记录
主要针对相关的面试内容，比如 C/C++，数据库，操作系统，计算机网络等等

# C/C++

> c/c++ 相关问题

## 一、基础语法知识

## 二、概念知识

### C++中什么是虚函数？

在 C++中，虚函数是一种允许在**派生类中重写基类函数**的机制。当一个函数被声明为虚函数时，它将允许通过**基类指针**或**引用**调用派生类中的该函数，这意味着在运行时将根据实际的对象类型而不是指针或引用类型来调用函数。这种机制被称为动态绑定或运行时多态性。

虚函数必须在基类中声明，并使用`virtual`关键字进行标记，而在派生类中重写虚函数时，可以使用`override`关键字进行标记以确保正确的函数覆盖。在 C++中，通过使用虚函数，可以实现多态性和基于类的程序设计。

### 什么是指针？

在 C++中，指针是一种变量类型，它存储一个内存地址。这个地址可以指向程序中任何其他变量或数据结构。

指针变量包含一个地址值，该地址值是一个无符号整数，指向存储在内存中的某个数据的位置。通过指针，我们可以直接访问或操作指向的数据，而无需拷贝或传递它们的副本。

指针在 C++中非常常见，并被广泛用于动态内存分配、函数参数传递、数据结构等方面。

### C++中什么是 const 关键字？

在 C++中，const 关键字用于指定一个变量或对象的值不能被修改。使用 const 可以帮助开发者确保程序的正确性和稳定性，防止意外地修改变量的值，从而产生潜在的错误。

在 C++中，const 可以用于以下几种场合：

1、声明常量：可以将 const 用于声明常量，例如：

```cpp
const int MAX_NUM = 100;
```

这里我们声明了一个名为 MAX_NUM 的常量，它的值被设置为 100，并且不能被修改。

2、函数参数：可以将 const 用于函数参数，以确保函数不会修改传入的参数值，例如：

```cpp
void print(const string& str) {
    cout << str << endl;
}
```

在这个函数中，我们使用 const 引用来传递字符串参数，以确保函数不会修改该参数的值。

3、成员函数：可以将 const 用于类成员函数，以确保函数不会修改对象的状态。例如：

```cpp
class MyClass {
public:
    void print() const {
        cout << "This is a const member function" << endl;
    }
};
```

在这个类中，我们声明了一个名为`print()`的成员函数，并使用`const`关键字将其标记为常量成员函数。这意味着该函数不能修改对象的任何成员变量。

使用`const`关键字可以提高代码的可读性和可维护性，并减少程序中出现的潜在错误。

### C++中什么是多态性？

多态性是 C++面向对象编程中的一个重要概念，它允许不同的对象以不同的方式响应相同的消息或方法调用。在 C++中，有两种类型的多态性：静态多态性（编译时多态性）和动态多态性（运行时多态性）。

静态多态性是指在编译时确定函数的重载形式或模板实例化的过程。例如，函数重载允许在同一个作用域中定义多个函数，只要它们的参数列表不同即可。在调用这些函数时，编译器将根据调用的参数类型来确定要调用哪个函数。

动态多态性是指在运行时确定调用哪个函数的过程。在 C++中，动态多态性通常通过虚函数实现。虚函数是一种特殊的成员函数，它可以在派生类中重新定义，从而使得基类指针可以在运行时动态地指向派生类对象，并调用相应的虚函数。

### 什么是函数重载？

函数重载是 C++中的一种特性，它允许在同一作用域内定义多个函数，这些函数具有相同的名称但具有不同的参数列表。在调用这些函数时，编译器会根据实参的类型、数量或顺序来确定调用哪个函数，以实现函数的多态性。

```cpp
int sum(int a, int b) {
    return a + b;
}
float sum(float a, float b) {
    return a + b;
}
```

在这个例子中，我们定义了两个名为 sum()的函数，一个用于计算两个整数的和，另一个用于计算两个浮点数的和。在主函数中，我们分别传递两个整数和两个浮点数作为实参来调用这两个函数。由于这两个函数的参数列表不同，因此编译器可以根据实参的类型来选择调用哪个函数。

函数重载可以让程序更加清晰、简洁，并且方便程序员编写代码。但是，函数重载要求函数名称和参数列表都不相同，否则会产生歧义或编译错误。因此，在设计函数重载时需要仔细考虑函数的名称和参数列表，以避免出现问题。

### C++中什么是模板？

在 C++中，模板是一种泛型编程的基础，它允许我们定义通用的类或函数，可以在不指定具体类型的情况下使用它们。模板参数是在编译时由用户提供的参数，它们用于在编译时生成普通类型或函数的构造。例如，我们可以定义一个函数模板：

```cpp
template <typename T>
T minimum(const T& lhs, const T& rhs) {
    return lhs < rhs ? lhs : rhs;
}
```

上述代码描述了一个具有单个类型参数 T 的泛型函数的模板，其返回值和调用参数（lhs 和 rhs）都具有此类型。C++模板的一个重要应用是 STL（标准模板库），它提供了一系列泛型数据结构和算法，例如容器、迭代器和算法等。C++的模板还支持对于整型或布尔值等数据类型的模板参数。

### 什么是指针和引用的区别？

在 C++中，指针和引用都是用于处理内存地址的概念，但它们之间有一些重要的区别。

指针是一个变量，存储的是一个地址，可以使用`*`运算符来访问该地址中存储的值，也可以使用指针运算符（如+、-、++、--等）来对地址进行操作。指针可以指向任何数据类型，包括基本类型、数组、结构体等，而且可以在运行时动态地分配和释放内存。指针可以为 NULL，表示指向无效的内存地址，如果对一个空指针解除引用，会导致程序崩溃。

引用是一种类似于指针的变量，但与指针不同，引用是一个别名，它始终指向一个已经存在的变量。引用使用&符号进行声明，并在声明时必须将其初始化为一个已存在的变量。引用在声明之后就不能改变其指向的变量，因此可以避免指针操作中的一些问题，例如空指针、悬空指针和非法指针等。引用通常用于函数调用中，以便可以通过传递引用而不是传递实际参数来避免对大量数据进行复制。

总之，指针和引用都可以用来操作内存地址，但它们在语义上有所不同。指针通常用于动态内存分配和数据结构，而引用通常用于函数参数传递和返回值。

### C++中什么是静态成员变量和静态成员函数？

在 C++ 中，静态成员变量和静态成员函数是与类本身而不是与类的实例相关联的。这些成员不是在每个对象中都有自己的拷贝，而是在整个类中共享。

静态成员变量的声明和定义都需要使用 `static` 关键字，而且必须在类定义的外部进行。静态成员变量可以被看作是全局变量，只不过它们的作用域是类内部的，而且只能通过类名加作用域运算符 `::` 来访问。例如，如果有一个类 `MyClass`，其中有一个静态成员变量 `count`，那么可以通过以下方式访问它：

```cpp
int MyClass::count = 0; // 静态成员变量定义和初始化
// ...
MyClass::count++; // 访问静态成员变量
```

静态成员函数也使用 `static` 关键字进行声明和定义，它们不能访问非静态成员变量和非静态成员函数，只能访问静态成员变量和静态成员函数，以及类的其他静态成员。可以通过类名和作用域运算符来调用静态成员函数。例如，假设 `MyClass` 类中有一个静态成员函数 `staticFunc()`，可以通过以下方式调用它：

```cpp
MyClass::staticFunc(); // 调用静态成员函数
```

静态成员变量和静态成员函数通常用于以下情况：

1. 统计类的实例个数：可以使用一个静态成员变量记录当前类的实例数，每次创建新实例时递增该变量。
2. 存储全局变量：可以使用一个静态成员变量来存储所有对象都需要访问的数据，这样可以避免为每个对象分配独立的存储空间。
3. 提供单例模式：可以使用一个静态成员函数返回类的单例实例，这样可以确保只有一个实例存在。

```cpp
#include <iostream>

class MyClass {
private:
    int m_x;
    static int s_count;
public:
    MyClass() : m_x(0) {
        s_count++;
    }
    static int getCount() {
        return s_count;
    }
};
int MyClass::s_count = 0;
int main() {
    MyClass obj1;
    MyClass obj2;
    std::cout << "Number of objects created: " << MyClass::getCount() << std::endl; // 输出 2
    return 0;
}
```

### 什么是虚拟析构函数？

虚拟析构函数是在父类中将析构函数声明为虚函数，以便在使用多态时正确删除对象。当我们在基类中使用指向子类对象的指针或引用调用 `delete` 时，只会调用父类的析构函数，这样可能会导致子类中的资源无法正确释放，因此需要使用虚拟析构函数。

在 C++ 中，我们可以将析构函数声明为虚函数，这可以通过在函数声明前加上 `virtual` 关键字来实现。以下是使用虚拟析构函数的示例代码：

```cpp
class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor" << std::endl;
    }
};
class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor" << std::endl;
    }
};
int main() {
    Base* b = new Derived();
    delete b;
    return 0;
}
```

在这个例子中，基类 `Base` 的析构函数被声明为虚拟的，这样当我们使用基类指针 `b` 来删除派生类 `Derived` 的对象时，将正确调用派生类的析构函数`~Derived()`。如果基类的析构函数不是虚拟的，只会调用基类的析构函数，而派生类的析构函数将不会被调用。

## 三、编译相关知识

### C++ 生成可执行文件的过程

![C++ 生成可执行文件的过程](../imgs/cpp%20executable%20file%20generation%20progress.png)
预处理阶段：
在这个阶段，编译器会扫描源代码文件，对所有以 `#` 开头的预处理指令进行处理，比如 `#include`、`#define`、`#ifdef` 等等。处理的结果会生成一个预处理文件（通常是以 `.i` 或 `.ii` 作为文件扩展名），其中包括所有预处理指令的处理结果，以及源代码文件中的内容。

编译阶段：
在这个阶段，编译器会把预处理阶段生成的预处理文件转换成汇编语言代码（通常是以 `.s` 作为文件扩展名）。这个过程包括词法分析、语法分析、语义分析等多个步骤。在这个过程中，编译器会检查源代码的语法和语义是否正确，以及将源代码转换成目标平台的汇编语言代码。

汇编阶段：
在这个阶段，汇编器会把编译阶段生成的汇编代码转换成机器语言代码（通常是以 `.o` 或 `.obj` 作为文件扩展名）。这个过程包括词法分析、语法分析、符号解析、指令生成等多个步骤。在这个过程中，汇编器会将汇编代码转换成机器语言代码，并生成与目标平台相关的重定位信息。

链接阶段：
在这个阶段，链接器会将多个目标文件和库文件合并成一个可执行文件或共享库文件。这个过程包括符号解析、重定位等多个步骤。在这个过程中，链接器会将所有目标文件和库文件中的符号进行解析，并根据重定位信息将代码和数据段的地址进行修正，以生成最终的可执行文件或共享库文件。

运行阶段：
在这个阶段，操作系统会加载可执行文件或共享库文件，将它们映射到进程的内存空间中，并启动程序执行。在程序执行过程中，操作系统会负责管理内存、进程、线程等资源，以及响应用户的输入和输出操作。

### 在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加`extern C`？

当在 C++ 程序中调用被 C 编译器编译后的函数时，需要使用 `extern C` 关键字来指定对应的 C 函数签名，这是因为 C++ 和 C 语言在编译器中处理函数名时有所不同。

在 C++ 中，函数名会被编译器进行改名以支持函数重载，即编译器会将函数名和参数类型一起编码为一个唯一的标识符。而在 C 中，函数名不会被编译器进行改名，因此函数名和参数类型组成了一个可识别的 C 函数签名。

因此，当在 C++ 程序中调用被 C 编译器编译后的函数时，需要使用 `extern C` 来告诉编译器使用 C 函数签名，以保证函数名和参数类型能够正确地匹配。否则，编译器可能会将函数名进行改名，导致调用失败。
